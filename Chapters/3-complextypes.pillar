!! Complex Types

We have seen in the last two chapters that types are a big deal in FFI call\-outs, since they govern how values are marshalled between C and Pharo.
The previous chapter explored the marshalling rules of basic types such as integers, floating point numbers, booleans and characters.
But in addition to these basic types, existing libraries may make use of more complex data-types, i.e., data-types that are built from simpler data-types.
This chapter builds on top of the knowledge of previous chapters to introduce these more complex types.

On the one hand, uFFI provides support to map C complex data-types,such as arrays and structures.
Arrays represent a bound sequence of values of a single data-type, e.g., a sequence of 10 integers.
Structures represent a collection of values of heterogeneous data-types, e.g., a group of an integer and a two booleans.

In addition, uFFI allows developers to define their own user-defined data-types in Pharo.
User-defined data-types range from simple type aliases, to user-defined classes wrapping external C values.

!!! Defining Type Aliases

A type alias is a user-defined alternative name for a type, which are useful in many different scenarios.
As one example, type aliases are useful to improve code readability, by creating domain specific types, e.g., ==age== => ==unsigned int==.
As another example, external libraries can come with their own user-defined and types and aliases, so having the same aliases in our FFI bindings can simplify writing those bindings.

!!!! A first type alias

In uFFI, type aliases are created with class variables: the class variable name is the alias name, while its value is the aliased type.
For example, we define our ==age== => ==unsigned int== alias as follows in our ==FFITutorial== class, and then execute the initialize method to make it run.

[[[language=smalltalk
Object subclass: #FFITutorial
  instanceVariableNames: ''
  classVariableNames: 'Age'
	package: 'FFITutorial'
  
FFITutorial class >> initialize
  Age := #uint
]]]

Once our type alias is defined, and the class side ==initialize== executed, we can use that type alias anywhere in our bindings in that hierarchy below ==FFITutorial==. For example, we can define our ==abs()== binding as follows.

[[[language=smalltalk
FFITutorial class >> abs: n [
	^ self ffiCall: #( Age abs ( Age n ) )
]
]]]

!!!! Valid values for type aliases

As we have seen above, uFFI type aliases are defined by normal assignments to class variables:

[[[language=smalltalk
Age := #uint
]]]

uFFI type alias names, on the left of the assignment, can have any name accepted as a class variable name.
Although other names are be accepted by Pharo class definitions, the convention tells class variables should be capitalized.
The value of a type alias, on the right of the assignment, could be either:
- a symbol with a type identifier to be resolved by uFFI, e.g., ==#'int'==, a shown above or;
- an already resolved type object, which we will study in subsequent sections

Before executing a call\-out, uFFI verifies all types used in the call\-out can be resolved to valid types, and will throw an exception if an error occurs while resolving it.

!!!! Sharing type aliases with shared pools

uFFI does not enforce how bindings should be structured by a developer.
A developer could choose to put all bindings in a single class, or, he could organize them in several classes even amongst several packages. Regardless of how the code is structured, it is most of the times useful to have user-defined type aliases available in all classes using the bindings. For this purpose, uFFI supports structuring type aliases in shared pools.

A typical usage of shared pools to define uFFI types is to define a ==MyLibraryTypes== shared pool as follows, as we did before to define constants:
[[[language=smalltalk
Object subclass: #FFITutorialTypes
  instanceVariableNames: ''
  classVariableNames: 'Age'
	package: 'FFITutorial'
  
FFITutorialTypes class >> initialize
  Age := #uint
]]]

We can then import the type aliases in the shared pool by 

[[[language=smalltalk
Object subclass: #FFITutorial
  ...
  poolDictionaries: 'FFITutorialTypes'
  ...
]]]

!!! Arrays

Arrays are a bound sequence of contiguous values.
In Pharo, an array object can contain any object, and specially, a single array can contain objects of different types.
For example, the following code snippet shows how a single array can contain integers, floats, strings and others.

[[[language=smalltalk
anArray := Array new: 7.
anArray at: 1 put: 3.1415.
anArray at: 5 put: 42.
anArray at: 7 put: 'Hello World'.

anArray.
 => #(3.1415 nil nil nil 42 nil 'Hello World')
]]]

In addition, Pharo arrays can be safely accessed without producing buffer over/underflows, because it performs bound checks on each array access. In other words, accessing outside the bounds of a Pharo array yields an exception instead of accessing data ""outside"" the array.

[[[language=smalltalk
anArray := Array new: 1.

anArray at: 2
 => Out of Bounds Exception!
]]]

C arrays behave partially like Pharo arrays: they are contiguous sequences of values.
However, C arrays are constrained to contain values of a single type, and accessing outside of their bounds is not checked before the access, producing buffer over/underflows.

Because of these differences and differences in their internal representation, uFFI does not automatically marshall Pharo arrays into C arrays. Instead, uFFI provides a specialized array class to manipulate arrays: the ==FFIArray== class.

!!!! Creating instances

==FFIArray==s are created using the ==newType:size:== or the  ==externalNewType:size:== instance creation methods. The former will allocate an array in the Pharo heap, while the latter one will allocate the array in the C heap.

[[[language=smalltalk
"In the pharo heap"
array := FFIArray newType: #char size: 10.

"In the C heap"
array := FFIArray externalNewType: #char size: 10.
]]]

==FFIArray==s allocated in the C heap are not moved and their memory is not released automatically.
It is the developer's responsibility to free it.
On the other hand, ==FFIArray==s allocated in the Pharo heap can be moved by the garbage collector, so they should be pinned in memory before being safely used in FFI calls.
Also, ==FFIArray==s in the Pharo heap are managed by Pharo's garbage collector, and will be collected if no other Pharo objects reference it. Be careful, an ==FFIArray== in the Pharo heap referenced from the C heap will still be garbage collected making the pointer in the C heap a dangling pointer.

!!!! Accessing my instances

The elements in an ==FFIArray== are accessed as any other Pharo array, using the ==#at:== and ==#at:put:== methods.
Its size is accessed with the ==#size== method, using 1-based indexes like in Pharo.

[[[language=smalltalk
array at: 1 "for the first element".
array at: n "for the nth element".
]]]

If the array is allocated in the Pharo heap, array accesses will be bound checked and throw an exception in case of out-of-bounds access. Otherwise, if the array is allocated in the C heap, array accesses may run into buffer over/underflows.

!!!! Reusable Array types

From time to time, we need to create several array instances of the same type and size.
Besides instantiating single arrays, ==FFIArray== can define array types, using the ==newArrayType:size:== method.
An array type knows the types of its elements and its size and we can simply allocate it using the ==new== or ==externalNew== messages to allocate it in the Pharo heap or the C heap respectively.

[[[language=smalltalk
char128Type := FFIArray newArrayType: #char size: 128.

"In Pharo heap"
newArrayOf128Chars := char128Type new.

"In C heap"
newArrayOf128Chars := char128Type externalNew.
]]]

==FFIArray==s created this way can be used as any other ==FFIArray==.
We will see in the next section how this array definition is useful to combine arrays inside structures.

!!! Structures
The ==FFIExternalStructure== object is used to manipulate C structures from Pharo.
From the standard C library we can use the ==div()== function as an example.
Given a numerator and denominator, it returns a structure holding the quotient and remainder. In stdlib.h we find these definitions:

[[[
typedef struct
{
	int quot;	/* Quotient.  */
	int rem;	/* Remainder.  */
} div_t;

div_t div (int __numer, int __denom)
]]]

Converting these to FFI definitions we get...
[[[
FFIExternalStructure subclass: #Div_t
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'UnifiedFFI-ExampleLibC'
]]]


[[[
Div_t class >> fieldsDesc [
	"self rebuildFieldAccessors"
	^ #(
		int quot;
		int rem;
		)
]
]]]

[[[
LibC class >> div_numer: numer denom: denom [
	^ self ffiCall: #( Div_t div( int numer, int denom ) ) module: LibC
]
]]]

So lets try it out.

[[[
LibC div_numer: 7 denom: 2 
	"Div_t ( quot: 3	rem: 1)"
]]]
 
Now for another example, imagine you need to manipulate the following C structure from Pharo:

[[[
struct My_Structure {
	uint8 id;
	char * name;
	uint name_length;
}
]]]

The first step is to create a subclass of ==FFIExternalStructure== that we name ==MyStructure==:

[[[
FFIExternalStructure subclass: #MyStructure
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'FFIDemo'
]]]

Then, we need to describe the structure. This is done by overriding the ==FFIExternalStructure class >> #fieldsDesc== method.
The syntax used to do it is pretty close to the C syntax:

[[[
MyStructure class >> #fieldsDesc [
	^ #(
	uint8 id;
	char * struct_name;
	uint name_length;
	)
]
]]]

Once the structure is described, you can generate the accessors by evaluating ==MyStructure rebuildFieldAccessors==.
This will generate accessors and mutators on instance side of ==MyStructure==.

Now we are going to make the use of this structure a bit easier. As you saw before, the structure holds a char pointer
to represent its name (as a ==String==) and it also holds the length of this ==String== in ==name_length== field.

Right now, you can use the structure like this:
[[[
myStruct := MyStructure externalNew. "Use #externalNew to create the object on the external heap."

"Create an external array of type char to hold the name."
newName := FFIExternalArray externalNewType: 'char' size: 3.
'foo' doWithIndex: [ :char :i |
	newName at: i put: char ].

"Set the name."
myStruct struct_name: newName.
myStruct name_length: newName size.

"Get the name."
structName := String
	newFrom: (FFIExternalArray
				fromHandle: myStruct struct_name getHandle type: 'char' size: myStruct name_length)
]]]

So to get the actual string, you need to take the char pointer and read ==name_length== char. We are going to wrap this
procedure in a new method:

[[[
MyStructure >> #structName [
	^ String
		newFrom: (FFIExternalArray
					fromHandle: self struct_name getHandle type: 'char' size: self name_length)
]
]]]

We want the same thing for the mutator. We do not want to matter with ==name_length== when setting ==struct_name==:

[[[
MyStructure >> #structName: aString [
	| externalArray |
	externalArray := FFIExternalArray externalNewType: 'char' size: aString size.
	aString doWithIndex: [ :char :i |
		externalArray at: i put: char ].
	self struct_name: externalArray.
	self name_length: aString size.
]
]]]

With the two preceding methods added, you can use ==MyStructure== the same way you use any other Pharo object:

[[[
"Of course you still need to use #externalNew!"
myStruct := MyStructure externalNew 
	structName: 'foo';
	id: 42;
	yourself.

myStruct structName. "foo"
myStruct id. "42"

myStruct structName: 'bar'.
myStruct structName. "bar"
]]]

!!! External objects

==FFIExternalObject== represents an object in the heap. An external object is a reference to any kind of data allocated in the heap mapped to a Smalltalk object.

This is confusing, so I will try to explain it better: When you allocate a region of memory in the heap, you get a pointer to that location, which does not represent anything. But often, frameworks will allocate structures, pointers, etc. which actually represents "an object" (not in the same sense as a Smalltalk object, but can be interpreted like one). For example,
to create a cairo surface, you can call this:

[[[
AthensCairoSurface class >> primImage: aFormat width: aWidth height: aHeight [
	^ self ffiCall: #(AthensCairoSurface * cairo_image_surface_create ( int aFormat,
	int aWidth, int aHeight) )
]
]]]

This will call the cairo function ==cairo_image_surface_create== but instead answer an ==ExternalAddress== it will create an
instance of ==AthensCairoSurface==, so you can treat the allocated pointer as an object.

Any class in the system can be an external object as long as either:
- it inherits from ==FFIExternalObject==; or
- it implements in its ""class side"" the method ==asExternalTypeOn:==.

You can check for implementors of ==asExternalTypeOn:== for examples, but they usually looks like this one:

[[[
AthensCairoCanvas class >> asExternalTypeOn: generator [
	"use handle ivar to hold my instance (cairo_t)"
	^ FFIExternalObjectType objectClass: self
]
]]]

@@note if you want to add the resource to an automatic free mechanism (to make GC frees also the external object), you need
to call ==autoRelease== (in case of children from FFIExternalObject) or implement similar mechanism.

@@note FFIExternalObject replaces NBExternalObject

!!! Opaque references
UnifiedFFI can work with opaque types (An opaque datatype is an structure which fields are not visible and is always accessed through a pointer 
to it, see *https://en.wikipedia.org/wiki/Opaque_data_type*).
This is usefull when working with obscure types (types we do not know its composition).
Take this as an example (taken from SQLite bindings): 

[[[ 
typedef struct sqlite3 sqlite3;
typedef struct sqlite3_stmt sqlite3_stmt;
]]]

this defines a type of a structure, and then is used along the api in this way: 

[[[
int sqlite3_open(char *filename, sqlite3 **handle);
char *sqlite3_column_name(sqlite3_stmt* aStatement, int aColumn)
]]]

this means we always access them through a reference. Now, we could declare the pointer to the structures (using ==FFIExternalObject==), 
but then our declarations wouldn't be as close to C as we want, as we need to change the declaration.

This is where ==FFIOpaqueObject== come to help: we declare it and then we use it always as reference.

In the case of the example, it would work like this: 

[[[ 
SQLite3 class >> initialize [
	sqlite3 := #FFIOpaqueObject.
	sqlite3_stmt :=	#FFIOpaqueObject.
]

SQLite3 class >> primOpen: filename handle: handle [
	self ffiCall: #(int sqlite3_open(String filename, sqlite3 **handle)).
]

SQLite3 >> primColumnBlob: aStatement column: aColumn [
	self ffiCall: #(const void *sqlite3_column_blob (sqlite3_stmt* aStatement, int aColumn))
]
]]]

!!! External address

External addresses (contained in the class ==ExternalAddress==) is the way we represent any kind of data ''outside''
Smalltalk. That means data (pointers, structures, arrays) who are allocated in the heap.

An ==ExternalAddress== can be:

- an allocation of memory (you can use ==ExternalAddress class >> allocate:== or ==ExternalAddress class >> gcallocate:==). Note that in case of ==#allocate:== you will need to ==#free== the external address later (==#gcallocate:== does that work for you).
- the result of a function call (usually it will come as part of an ==ExternalData==)

==ExternalData== represents an ==ExternalAddress== with an C type associated. For example,

Both ==ExternalAddress== and ==ExternalData== can be used as arguments when declaring functions with pointers as parameters,
for example:

[[[
LibC >> memCopy: src to: dest size: n [
	^ self ffiCall: #(void *memcpy(void *dest, const void *src, size_t n)
]
]]]