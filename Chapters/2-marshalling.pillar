!! Marshalling and Function Arguments

In the last chapter we looked at the basics of FFI call\-outs to define a Pharo uFFI binding to a function.
These first examples introduced the concepts of function lookup, library references, and marshalling of return values.
However, the idea of marshalling is not specific to the transformation of return values from C to Pharo: it also involves the transformation of Pharo values to C, and the sharing of values between the two environments.

This chapter presents marshalling in more detail, focusing on function arguments.
Our first examples show uFFI's capability of using literals as default argument values.
We then advance to other basic data types, from ==String==s and ==ByteArray==s all the way to C pointers and how to manipulate them within Pharo.
This chapter finishes by presenting the different marshalling rules in uFFI for basic types, particularly how to manage platform-specific types.

!!! A First Function Argument

Our previous ==clock== example was the one of the simplest uFFI examples possible, as it does not require passing any arguments, and because we could easily tweak the binding to map the return value to an unsigned integer.
To understand how to deal with function arguments, let\'s consider the ==abs()== function, which receives an integer argument and returns its absolute value.
The prototype of ==abs()==, another function available in the standard C library (allowing us to use our previous tutorial class), is declared as follows:

[[[
int abs( int n );
]]]

To create a binding for such a function requires that we somehow provide an ==int== argument in our binding.
To ease the construction of argument bindings, uFFI will automatically match the parameter names in our calling method to any corresponding function parameters that have the same name.
In other words, we can define our binding for ==abs()== as a method with a single ==n== argument as follows:

[[[language=smalltalk
FFITutorial class >> abs: n [
	^ self ffiCall: #( int abs ( int n ) )
]
]]]

Creating this binding does not really add any extra complexity to what we did in our previous examples.
We create a simple method that uses the ==ffiCall:== message, providing it an array argument enclosing a copy of the function's prototype.  (As with our earlier ==FFITutorial== class methods, we're assuming the continued use of our ==ffiModuleName== override to eliminate the need to add the ==module:== keyword).

The part that's new here is the introduction of the ==n== parameter and its C type, but no additional work is needed on our part to transform Pharo's object to a C value.  Also, notice that uFFI knows to distinguish the argument's declared ''type'' from its formal parameter ''name'', while simultaneously matching up the name with our Pharo method's formal argument.

We can even rename the parameter to use a more Pharo''ish'' naming style, such as ==anInteger==\:

[[[language=smalltalk
FFITutorial class >> abs: anInteger [
	^ self ffiCall: #( int abs ( int anInteger ) )
]
]]]

Finally, we can now use this binding from a playground as follows, with a regular Pharo ==SmallInteger==\:

[[[language=smalltalk
FFITutorial abs: -42.
]]]

!!! Marshalling

As we saw with return values in Chapter 1, Pharo's uFFI also manages the transformation of function arguments for us. The syntax we use may give the impression that uFFI simply copies the Pharo integer value to the C stack; however, the marshalling rules that uFFI must follow are not that straight-forward.  Pharo and C use different internal representations for their data types, each of which must be modified in order to be exchanged, and potentially in different ways, depending on the host platform.

To illustrate how marshalling works, let\'s consider the marshalling of a Pharo ==SmallInteger== to a C ==int== type, as in our example.
Internally, for efficiency purposes, Pharo represents ==SmallInteger==s directly in binary, rather than as an object pointed to in the heap.  Therefore, to differentiate integers from object pointers, Pharo tags ==SmallInteger== \"pointers\" with an extra bit to signify this special interpretation.

Let\'s consider the ==SmallInteger 2==; this value is represented in binary as the number ==2r10==, but is internally represented in Pharo as ==2r101==, where the ''least'' significant bit is shifted in as the added tag.  Since all Pharo object pointers are at least 32-bit aligned, we're guaranteed that their least significant bit will always be zero.  This makes a non-zero LSB a reliable indicator that we're dealing with a ==SmallInteger== rather than a heap pointer.  This is also why Pharo ==SmallInteger==s are 31 bits, ''not'' 32.

This resulting ''representation mismatch'' requires that the uFFI transform small integers to C ==int==s (and vice\-versa) as follows:
- a Pharo small integer transformed to a C value needs to be logically shifted to the right, ==2r101 >> 1==, transforming ==2r101== to ==2r10==.
- a C integer (representable in 31 bits or less) transformed to a Pharo small integer needs to be shifted to the left and incremented, ==(2r10 << 1) + 1==, transforming ==2r10== to ==2r101==.

!!!! Pharo-to-C Marshalling

When marshalling Pharo objects to C, uFFI decides the transformation rule to use depending on two pieces of information.
First, it considers the concrete type of the marshalled Pharo object, ''its class''.
Second, it considers the C type defined in the function binding as the target transformation type.
At run time, when the binding method is executed, uFFI reads the type of the binding argument and transforms the argument object to the indicated C type's representation, performing a type cast/coercion as necessary.

These transformation rules have several consequences, which we will illustrate with several cases, using our previous ==abs:== binding example.

- ==SmallInteger==s are transformed to ==int==s as expected (since they cannot overflow)\:

[[[language=smalltalk
FFITutorial abs: -42.
=> 42
]]]

- Pharo integers that overflow the C ==int== size are coerced by truncating to size, producing results similar to what a C program would produce\:

[[[language=smalltalk
FFITutorial abs: SmallInteger maxVal.  "Cast to all 1\'s"
=> 1
]]]

- Pharo floats provided for C ==int== arguments will be truncated to produce an integer\:

[[[language=smalltalk
FFITutorial abs: Float pi.
=> 3
]]]

- Pharo objects that are incompatible with C ==int== type are rejected, and an exception is thrown\:

[[[language=smalltalk
FFITutorial abs: Object new.
=> Error: Could not coerce arguments
]]]

!!!! C-to-Pharo Marshalling

A similar\-yet\-different story happens when marshalling C values to Pharo objects.
In this case uFFI decides the marshalling rule based on just the specified return type.
At run time, when the binding method is executed and the C function returns, uFFI transforms the (expected) return value into the closest Pharo type corresponding to the declared C type.

For example, a delared ==int== return type will cause uFFI to interpret the returned value as either a ==SmallInteger== or ==Large(Positive\|Negative)Integer==, depending on the size and sign of the data; a C
==float== or ==double== type will interpret the returned data as a Pharo ==Float==.

!!!! Marshalling of Incorrectly Declared Types

The marshalling rules we have seen above show that the way in which we specify function types is ''crucial'' to the correct behavior of our bindings, and thus our applications.
In other words, call\-out bindings require that C types are correctly specified, otherwise run\-time errors \-\- or even worse, viable but incorrect value transformations \-\- may happen.

Let\'s consider as an example what happens if we create a companion ==abs:== binding to operate on a ==Float== argument instead of an integer, but which uses the same C ==abs()== function\:

[[[language=smalltalk
FFITutorial class >> floatAbs: aFloat [
	^ self ffiCall: #( int abs ( float aFloat ) )
]
]]]

Now let\'s we evaluate this version in a playground using a negative ==Float== value:

[[[language=smalltalk
FFITutorial floatAbs: -1.0.
=> 0
]]]

Although we expected the message to return ==1== (because the return value is still of type ==int==), this example returns ==0==.
To understand this result, we need to understand that our bindings, and the way we express their C types, are ''independent'' of the actual function implementation we are calling.
In other words, even if we \'set\' the type of ==abs()== to ==float==, the ==abs()== function in our system remains built and compiled to work only on C ==int== values.  We're not ''compiling'' the C functions in Pharo, only attaching and calling them.  So we must strictly and carefully adhere to their documented function declarations.

What happens \"under the hood\" in this example is that uFFI transforms our ==\-1.0== Pharo float into a C float, then pushes it on the stack and calls the ==abs()== function.  The function uses that value, but considers it to be an integer.
And it happens that integers and floats have the same bit size (32 bits), but vastly different representations in C.
This produces either hilarious or ''dangerous'' results...

A similar problem arises if the return type of a function is incorrectly specified.
Let\'s take for example a slightly modified version of our original ==abs:== binding, this time declaring a C float return type\:

[[[language=smalltalk
FFITutorial class >> floatReturnAbs: anInteger [
	^ self ffiCall: #( float abs ( int anInteger ) )
]
]]]

When this call returns, uFFI will interpret the returned value as a C float, and try to marshall it to a Pharo ==Float==\:

[[[language=smalltalk
FFITutorial floatReturnAbs: -3.
=> -1.07374176e8
]]]

However, since the implementation of ==abs()== actually returns an ==int==, the bits are wrongly interpreted, producing not an error (in this case), but a strange value \-\- ''one that your application might not detect''.  And if this kind of misinterpretation is only \"slightly off\", it can lead to buggy behavior that is maddeningly difficult to diagnose.

While writing library bindings with uFFI is fun and simple, the binding developer needs to make sure that the types are correctly declared, and that the correct version of the library is being used. Fortunately, for mature libraries, most of the time it is sufficient to simply copy and paste the function declarations.

!!! Function Argument Bindings

We have seen in the earlier introductory example how to use method parameters as arguments when writing function bindings.
In this section we explore other ways to define arguments, in particular literal integers, instance variables, and class variables.

!!!! Literal Integer Arguments

From time to time we will find ourselves calling C functions that require many more parameters than the ones we are actually interested in providing.
For example, C functions may have extra parameters to select or control certain options and configurations, or they may have parameters that are only necessary in particular cases (and which are ignored in others).

Although parameters such as these are deemed ''optional'', we cannot leave them out of our binding definition \-\- they still need to be there for the C call to occur correctly. To make it easier to deal with such optional parameters, uFFI allows Pharo literal objects to be provided as function arguments.

To see how this works, let\'s first imagine that for some reason we needed to call the ==abs()== function with the ==\-42== argument exclusively.
Using what we have learned up to this point, a simple way to define such a binding would be to define a normal Pharo method calling our binding with the hard-coded value ==\-42==\:

[[[language=smalltalk
FFITutorial class >> absMinusFortyTwo [
	^ self abs: -42
]
]]]

This approach is convenient when we want both ==abs:== and ==absMinusFortyTwo== to be exposed to our user.
It certainly benefits from the binding being declared only once, allowing us to isolate potential marshalling mistakes in a single location.
However, we may not want to couple to the ==abs:== method directly, as we\'re doing in this case.  Instead, we want to provide ==\-42== directly to the C ==abs()== function, as a literal (canned-in) value.

To provide for this, uFFI supports the usage of literal arguments in function bindings.  Instead of using a method parameter as argument in the function binding, we can specify a literal value with some additional new syntax\:

[[[language=smalltalk
FFITutorial class >> absMinusFortyTwo [
	^ self ffiCall: #( int abs ( (int) -42 ) )
]
]]]

Notice that we don't just type in a Pharo integer for the expected argument; literal values such as integers must be preceded by a C type declaration, such as the ==(int)== above, in parenthesis (to make it clear to the parser that it\'s a ''type specifier'').
This type information is needed by uFFI to correctly determine how to transform the Pharo integer, given the many different forms in which it could be rendered.

Consider that in the case of C integers, a number can be signed or unsigned, and can occupy different sizes such as 8, 16, 32, or 64 bits.  Pharo can't guess; the C function expects a specific type to be provided, and the Pharo object containing the value doesn't reflect this.  We have to explicitly \'type\' the literal when we type it in.

We will present more detail about the different data types accepted by uFFI, in particular integer data types, in an upcoming section of this chapter.

!!!! Variables

In the methods above we used literal numbers as arguments in uFFI call\-outs.
Although handy, these literal numbers fall into the category of so\-called \"magic numbers\"\: Embedded literals in code that offer no explanation of where they came from, why they were chosen, or how they were calculated.  (These are distinguished from ''manifest constants'', which are more-or-less self-explanatory, such as using ''pi'' in angle calculations or \'2\' when we need half of a quantity.)

Embedding magic numbers in methods is a ''code smell'' and should be avoided.  One way to handle these kinds of values is to parameterize them\: assign them names, usually as a variable or named constant.  C libraries often define such constants using ==\#define== pre-processor statements such as\:

[[[language=c
  #define magicNumber -42
]]]

In Pharo, we can take a similar approach by defining such values in class variables.
We only need to change the definition of our ==FFITutorial== class to include a class variable such as ==TheAnswer== (which is consequently capitalized), and then define a class-side ==initialize== method to set its value (''and explain why''). Do ""not"" forget to execute this ==initialize== method, otherwise the value won\'t get set\!

[[[language=smalltalk
Object subclass: #FFITutorial
	...
	classVariableNames: 'TheAnswer'
  ...

FFITutorial class >> initialize [
	"Set this to -42 because.. Life, the Universe, and Everything"
	TheAnswer := -42.
]
]]]

Finally, we update our call\-out binding to use our class variable \-\- and note that we still need to provide its type explicitly\:

[[[language=smalltalk
FFITutorial class >> absMinusFortyTwo [
  ^ self ffiCall: #( int abs ( (int) TheAnswer) )
]
]]]

Just as with class variables, uFFI integrates transparently with variables defined in shared pools.
Shared pools are useful for grouping common constants that need to be shared between different classes, bindings, or even libraries.

The following code illustrates how we can modify our code to put our variable(s) in a shared pool.
Notice that the only code that changes is the class defining the variable.
The binding using the variable remains unchanged.

[[[language=smalltalk
SharedPool subclass: #FFITutorialPool
	...
	classVariables: 'TheAnswer'
  ...

FFITutorialPool class >> initialize [
	"Set this to -42 because.. Life, the Universe, and Everything"
	TheAnswer := -42.
]

Object subclass: #FFITutorial
	...
	poolDictionaries: 'FFITutorialPool'
  ...

FFITutorial class >> absMinusFortyTwo [
  ^ self ffiCall: #( int abs ( (int) TheAnswer ) )
]
]]]

Using a shared pool does not change the normal Pharo usage of uFFI. If you want to learn more about Pharo shared pools, we recommend you take a look at ''Pharo by Example 8.0''.

We can also pass ==self== as an argument to a C call.
Suppose we want to add the ==abs()== function call to an extention of the class ==SmallInteger==, in a method named  ==absoluteValue==.  This would allows us to write expressions such as ==\-50 absoluteValue==.

To do this, we simply add an ==absoluteValue== method to ==SmallInteger== and directly pass ==self== as a (typed) argument, like so\:

[[[language=smalltalk
SmallInteger >> absoluteValue [
	^ self ffiCall: #( int abs ( int self ) ) module: LibC
]
]]]

It is is also possible to pass instance variables, but we let you experiment with that as an exercise... \:\^)

!!! uFFI Data Types

!!!! Passing strings

As you may know strings in C are sequences of characters terminated with a special character: ==\\0==.
It is then interesting to see how FFI-NB deals with them since they are an important data structure in C.
For this, we will call the very well known ==strlen== function.
This function requires a string as argument and returns its number of characters.

""C header"".
[[[
int strlen ( const char * str );
]]]

""Smalltalk binding"".
[[[language=smalltalk
FFICExamples class >> stringLength: aString [
	^ self ffiCall: #( int strlen (String aString) ) module: LibC
]
]]]



!!! Example analysis

You may have noticed that the callout description is not exactly the same as the C function header.

In the signature ==#( int strlen (String aString) )== there are two differences with the C signature.
- The first difference is the const keyword of the argument. For those not used to C, that's only a modifier keyword that the compiler takes into account to make some static validations at compile time. It has no value when describing the signature for calling a function at runtime.
- The second difference, an important one, is the specification of the argument. It is declared as ==String aString== instead of ==char * aString==. With ==String aString==, FFI-NB will automatically do the arguments conversion from Smalltalk strings to C strings (null terminated). Therefore it is important to use String and not ==char *==. In the example, the string passed will be put in an external C ==char== array and a null termination character will be added to it. Also, this array will be automatically released after the call ends. This automatic memory management is very useful but we can also control it as we will see later. Using ==(String aString)== is equivalent to ==(someString copyWith: (Character value:0)== as in ==FFICExamples stringLength: (someString copyWith: (Character value:0)==. Conversely, FFI-NB will take the C result value of calling the C function and convert it to a proper Smalltalk Integer in this particular case.

!!! Passing two strings

We will now call the ==strcmp== function, which takes two strings as arguments and returns -1, 0 or 1 depending on
the relationship between both strings.

""C header""
[[[
	int strcmp ( const char * str1, const char * str2 );
]]]

""Smalltalk binding""
[[[language=smalltalk
FFICExamples class >> stringCompare: aString with: anotherString [
	^ self ffiCall: #( int strcmp (String aString, String anotherString) ) module: LibC
]
]]]

Notice that you can add arguments by appending them to the arguments array, using a comma to separate them. Also
notice that you have to explicitly tell which object is going to be sent for each argument, as already told. In this
case, aString is the first one and anotherString is the second one.

!!! Getting return value from a function

Symmetrically to arguments, returned values are also marshalled, it means that C values are converted to Smalltalk objects.

We already saw that implicitly through multiple examples since the beginning of the chapter.
For example in the ==abs== example, the result is converted from an int to a SmallInteger.
In the ==floor== example, the  result is converted from a double to a Float.

But FFI-NB can also convert types a bit more complex than atomic types, like String

[[[language=smalltalk
FFICExamples >> #getEnv: aString [
	^ self ffiCall: #( String getenv (String string) ) module: LibC
]
]]]

There is a mapping defined for each atomic type. About a bit more complex objects (like external objects or structures),
we will talk in following sections.

!!! Returning "void *"

Take this call as an example:

[[[language=smalltalk
FFICExamples class >> malloc: aNumber [
	^ self ffiCall: #( void * malloc ( int aNumber ) )
]
]]]

This is a special case of return: when there is a function who answers a ''void *''. In this case, since FFI-NB cannot know
which kind of object it represents, it will answer an instance of ==ExternalData== (we will see this in next section).

@@todo Luc illustrate that when NULL (a pointer with value 0) is returned, it is automatically converted to nil
