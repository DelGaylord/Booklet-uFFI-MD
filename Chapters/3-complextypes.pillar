!! Complex Types

We have seen in the last two chapters that types are a big deal in FFI call\-outs, since they govern how values are marshalled between C and Pharo.
The previous chapter explored the marshalling rules of basic types such as integers, floating point numbers, booleans and characters.
But in addition to these basic types, existing libraries may make use of more complex data-types, i.e., data-types that are built from simpler data-types.
This chapter builds on top of the knowledge of previous chapters to introduce these more complex types.

This chapter starts by showing how to define type aliases. Type aliases are user-defined alternative names for other types, usually used to improve the readability of the code.
In addition, you'll see further in this chapter how uFFI exploits them to define more complex types.

uFFI provides support to map C complex data-types,such as arrays, structures, enumerations and unions.
Arrays are data-types defining a bound sequence of values of a single data-type, e.g., a sequence of 10 integers.
Structures are data-types defining a collection of values of heterogeneous data-types, e.g., a group of an integer and a two booleans.
Enumerations are data-types defining a finite set of named values, e.g., the characters between a and z.
Unions are data-types defining a single value that can be interpreted with different internal representations, e.g., we may want to see a float as an int to extract its mantissa.

!!! Defining Type Aliases

A type alias is a user-defined alternative name for a type, which are useful in many different scenarios.
As one example, type aliases are useful to improve code readability, by creating domain specific types, e.g., ==age== => ==unsigned int==.
As another example, external libraries can come with their own user-defined and types and aliases, so having the same aliases in our FFI bindings can simplify writing those bindings.

!!!! A first type alias

In uFFI, type aliases are created with class variables: the class variable name is the alias name, while its value is the aliased type.
For example, we define our ==age== => ==unsigned int== alias as follows in our ==FFITutorial== class, and then execute the initialize method to make it run.

[[[language=smalltalk
Object subclass: #FFITutorial
  instanceVariableNames: ''
  classVariableNames: 'Age'
	package: 'FFITutorial'
  
FFITutorial class >> initialize
  Age := #uint
]]]

Once our type alias is defined, and the class side ==initialize== executed, we can use that type alias anywhere in our bindings in that hierarchy below ==FFITutorial==. For example, we can define our ==abs()== binding as follows.

[[[language=smalltalk
FFITutorial class >> abs: n [
	^ self ffiCall: #( Age abs ( Age n ) )
]
]]]

!!!! Valid values for type aliases

As we have seen above, uFFI type aliases are defined by normal assignments to class variables:

[[[language=smalltalk
Age := #uint
]]]

uFFI type alias names, on the left of the assignment, can have any name accepted as a class variable name.
Although other names are be accepted by Pharo class definitions, the convention tells class variables should be capitalized.
The value of a type alias, on the right of the assignment, could be either:
- a symbol with a type identifier to be resolved by uFFI, e.g., ==#'int'==, a shown above or;
- an already resolved type object, which we will study in subsequent sections

Before executing a call\-out, uFFI verifies all types used in the call\-out can be resolved to valid types, and will throw an exception if an error occurs while resolving it.

!!!! Sharing type aliases with shared pools

uFFI does not enforce how bindings should be structured by a developer.
A developer could choose to put all bindings in a single class, or, he could organize them in several classes even amongst several packages. Regardless of how the code is structured, it is most of the times useful to have user-defined type aliases available in all classes using the bindings. For this purpose, uFFI supports structuring type aliases in shared pools.

A typical usage of shared pools to define uFFI types is to define a ==MyLibraryTypes== shared pool as follows, as we did before to define constants:
[[[language=smalltalk
Object subclass: #FFITutorialTypes
  instanceVariableNames: ''
  classVariableNames: 'Age'
	package: 'FFITutorial'
  
FFITutorialTypes class >> initialize
  Age := #uint
]]]

We can then import the type aliases in the shared pool by 

[[[language=smalltalk
Object subclass: #FFITutorial
  ...
  poolDictionaries: 'FFITutorialTypes'
  ...
]]]

!!! Arrays

Arrays are a bound sequence of contiguous values.
In Pharo, an array object can contain any object, and specially, a single array can contain objects of different types.
For example, the following code snippet shows how a single array can contain integers, floats, strings and others.

[[[language=smalltalk
anArray := Array new: 7.
anArray at: 1 put: 3.1415.
anArray at: 5 put: 42.
anArray at: 7 put: 'Hello World'.

anArray.
 => #(3.1415 nil nil nil 42 nil 'Hello World')
]]]

In addition, Pharo arrays can be safely accessed without producing buffer over/underflows, because it performs bound checks on each array access. In other words, accessing outside the bounds of a Pharo array yields an exception instead of accessing data ""outside"" the array.

[[[language=smalltalk
anArray := Array new: 1.

anArray at: 2
 => Out of Bounds Exception!
]]]

C arrays behave partially like Pharo arrays: they are contiguous sequences of values.
However, C arrays are constrained to contain values of a single type, and accessing outside of their bounds is not checked before the access, producing buffer over/underflows.

Because of these differences and differences in their internal representation, uFFI does not automatically marshall Pharo arrays into C arrays. Instead, uFFI provides a specialized array class to manipulate arrays: the ==FFIArray== class.

!!!! Creating ==FFIArray==s

==FFIArray==s are created using the ==newType:size:== or the  ==externalNewType:size:== instance creation methods. The former will allocate an array in the Pharo heap, while the latter one will allocate the array in the C heap.

[[[language=smalltalk
"In the pharo heap"
array := FFIArray newType: #char size: 10.

"In the C heap"
array := FFIArray externalNewType: #char size: 10.
]]]

==FFIArray==s allocated in the C heap are not moved and their memory is not released automatically.
It is the developer's responsibility to free it.
On the other hand, ==FFIArray==s allocated in the Pharo heap can be moved by the garbage collector, so they should be pinned in memory before being safely used in FFI calls.
Also, ==FFIArray==s in the Pharo heap are managed by Pharo's garbage collector, and will be collected if no other Pharo objects reference it. Be careful, an ==FFIArray== in the Pharo heap referenced from the C heap will still be garbage collected making the pointer in the C heap a dangling pointer.

!!!! Manipulating ==FFIArray== instances

The elements in an ==FFIArray== are accessed as any other Pharo array, using the ==#at:== and ==#at:put:== methods.
Its size is accessed with the ==#size== method, using 1-based indexes like in Pharo.

[[[language=smalltalk
array at: 1 "for the first element".
array at: n "for the nth element".
]]]

If the array is allocated in the Pharo heap, array accesses will be bound checked and throw an exception in case of out-of-bounds access. Otherwise, if the array is allocated in the C heap, array accesses may run into buffer over/underflows.

!!!! Reusable ==FFIArray== types

From time to time, we need to create several array instances of the same type and size.
Besides instantiating single arrays, ==FFIArray== can define array types, using the ==newArrayType:size:== method.
An array type knows the types of its elements and its size and we can simply allocate it using the ==new== or ==externalNew== messages to allocate it in the Pharo heap or the C heap respectively.

[[[language=smalltalk
char128Type := FFIArray newArrayType: #char size: 128.

"In Pharo heap"
newArrayOf128Chars := char128Type new.

"In C heap"
newArrayOf128Chars := char128Type externalNew.
]]]

==FFIArray==s created this way can be used as any other ==FFIArray==.
We will see in the next section how this array definition is useful to combine arrays inside structures.

!!! Structures

A structure is data-type that joins together a group of variables, so-called fields.
Each field of a structure has a name and a type.
Structures are often used to group related values, so they can be manipulated together.
For example, let's consider a structure that models a fraction, i.e., a number that has a numerator and a denominator. Both numerator and denominator can be defined as fields of type ==int==.
Such fraction structure data-type, and a function calculating a double precision floting point number from it, are defined in C as follows:

[[[language=c
typedef struct
{
	int numerator;
	int denominator;
} fraction;

double fraction_to_double(fraction* a_fraction){
  return a_fraction -> numerator / (double)(a_fraction -> denominator);
}
]]]

!!!! Defining a structure with ==FFIStructure==

Structures are declared in uFFI as subclasses of the ==FFIStructure== class defining the same fields as defined in C.
For example, defining our fraction structure is done as follows, defining a subclass of ==FFIStructure==, a ==fieldsDesc== class-side method returning the specification of the structure fields, and finally sending the ==rebuildFieldAccessors== message to the structure class we created.

[[[language=smalltalk
FFIStructure subclass: #FractionStructure
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'FFITutorial'

FractionStructure class >> fieldsDesc [
	^ #(
		int numerator;
		int denominator;
		)
]

FractionStructure rebuildFieldAccessors.
]]]

Doing this will automatically generate some boilerplate code to manipulate the structure.
You will see that the structure class gets redefined as follows, containing some auto-generated accessors.

[[[language=smalltalk
FFIStructure subclass: #FractionStructure
	instanceVariableNames: ''
	classVariableNames: 'OFFSET_DENOMINATOR OFFSET_NUMERATOR'
	package: 'FFITutorial'

FractionStructure >> denominator [
	"This method was automatically generated"
	^handle signedLongAt: OFFSET_DENOMINATOR
]

FractionStructure >> denominator: anObject [
	"This method was automatically generated"
	handle signedLongAt: OFFSET_DENOMINATOR put: anObject
]

FractionStructure >> numerator [
	"This method was automatically generated"
	^handle signedLongAt: OFFSET_NUMERATOR
]

FractionStructure >> numerator: anObject [
	"This method was automatically generated"
	handle signedLongAt: OFFSET_NUMERATOR put: anObject
]
]]]

Once a structure type is defined, we can allocate structures from it using the ==new== and ==externalNew== messages, that will allocate it in the Pharo heap or the external C heap respectively.

[[[language=smalltalk
"In Pharo heap"
aFraction := FractionStructure new.

"In C heap"
aFraction := FractionStructure externalNew.
]]]

We read or write in our structure using the auto-generated accessors.

[[[language=smalltalk
aFraction numerator: 40.
aFraction denominator: 7.
]]]

And we can use it as an argument in a call\-out by using its type.

[[[language=smalltalk
FFITutorial >> fractionToDouble: aFraction [
  ^ self ffiCall: #(double fraction_to_double(FractionStructure* a_fraction))
]

FFITutorial new fractionToDouble: aFraction.
>>> 5.714285714285714
]]]

!!!! Structures embedding arrays

Arrays in C can appear embedded in structures defined as follows, where a structure contains an array of four ints.

[[[language=c
struct {
	int some_array[4];
}
]]]

Constrastingly with a struct containing ''a pointer'' to an array, the structs created from the definition above will contain the entire array allocated within the struct. Choosing between a struct that embeds an array or one that references an array through a pointer is a responsibility of the author of the C library we are binding, and it is outside the scope of the booklet. However, different structures are defined differently in uFFI. 

Defining the structure above in uFFI requires that we define an array type of size 4 for our ==some_array== field.
We can define such user defined type as a type alias in our class-side, import our type pool in our structure class and then use our type in our field definitions.

[[[language=smalltalk
FFITutorialTypes class >> initialize [
  int4array := FFIArray newArrayType: #int size: 4.
]
  
FFIStructure subclass: #EmbeddingArrayStructure
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 'FFITutorialTypes'
  package: 'FFITutorial'
  
EmbeddingArrayStructure class >> fieldsDesc [
  ^ #(
  int4array some_array;
  )
]

EmbeddingArrayStructure rebuildFieldAccessors.
]]]

!!! Enumerations

Enumerations are data-types defining a finite set of named values.
For example, let's consider we want to create a data-type to identify the different positions of players inside a football match: goalkeeper, defender, midfielder, forward. Such data-type can be defined in C as an enumeration as follows:

[[[language=c
typedef enum {
  goalkeeper,
  defender,
  midfielder,
  forward
} position;
]]]

We can then use ==position== as a type, and the values defined within it as valid values for ==position==.


[[[language=c
position myPosition = defender;
]]]

!!!! The values of C enumerations

To better understand how to map C enumerations using uFFI, we must before understand how C assigns value to each of the elements in the enumeration.
Internally, C assigns to each of the elements of the enumeration a sequencial numeric value starting from 0 (zero).
In other words, ==goalkeeper== has a value of 0, ==defender== has a value of 1, and so on.
C allows developers to specify the values they want too, using an assignment-like syntax.

[[[language=c
typedef enum {
  goalkeeper = 42,
  defender,
  midfielder,
  forward
} position;
]]]

We can explicitly assign values to any of the elements of the enumeration.
We may leave values without explicit values, in which case they will be automatically assigned a value following its previous value. And finally, many elements in the enumeration may have the same value.
The example enumeration below shows these subtleties.

[[[language=c
#include <assert.h>
#include <limits.h>

enum example {
    example0,            /* will have value 0 */
    example1,            /* will have value 1 */
    example2 = 3,        /* will have value 3 */
    example3 = 3,        /* will have value 3 */
    example4,            /* will have value 4 */
    example5 = INT_MAX,  /* will have value INT_MAX */
    /* Defining a new value after this one will cause an overflow error */
};
]]]

!!!! Defining an enumeration using ==FFIEnumeration==

Enumerations are declared in uFFI as subclasses of the ==FFIEnumeration== class defining the same elements as defined in C, and with their same values.
For example, defining our example enumeration is done as follows, defining a subclass of ==FFIEnumeration==, a ==enumDecl== class-side method returning the specification of the enumeration elements, and finally sending the ==initialize== message to the enumeration class we created.

[[[language=smalltalk
FFIEnumeration subclass: #ExampleEnumeration
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'FFITutorial'

ExampleEnumeration class >> enumDecl [
	^ #(
    example0 0
    example1 1
    example2 3
    example3 3
    example4 4
    example5 2147483647
		)
]

ExampleEnumeration initialize.
]]]

Doing this will automatically generate some boilerplate code to manipulate the enumeration.
You will see that the enumeration class gets redefined as follows creating and initializing a class variable for each of its elements.

[[[language=smalltalk
FFIEnumeration subclass: #ExampleEnumeration
  instanceVariableNames: ''
  classVariableNames: 'example0 example1 example2 example3 example4 example5'
  package: 'FFITutorial'
]]]

To use the values of enumerations in our code, it is enough to import it as a pool dictionary, since uFFI enumerations are shared pools.

[[[language=smalltalk
Object subclass: #FFITutorial
  ...
  poolDictionaries: 'ExampleEnumeration'
  ...
]]]

!!! Unions

!!! Conclusion