!! Marshalling and Function Arguments

In the last chapter we have seen the basics of FFI callouts to define a FFI binding to a function.
This first example introduced the ideas of function lookup, library and marshalling of return values.
However, the idea of marshalling is not specific to the transformation of return values from C to Pharo: it also involves the transformation of Pharo values to C, and the sharing of values between them.

This chapter presents marshalling more in detail, using function arguments as our main case study.
Our first examples show uFFI's capability of using literals as default argument values.
We then advance into other basic data types such as Strings and ByteArrays, and finally to C pointers and how to manipulate them from Pharo.
This chapter finishes by presenting the different marshalling rules in uFFI for basic types and particularly how to manage platform-specific types.

!!! A First Function Argument

The previous ==clock== example was the one of the simplest examples possible as it does not receive any arguments and we could easily tweak the binding to map the return value to an unsigned integer.
To study function arguments let's consider the ==abs()== function, which receives an integer argument and returns its absolute value.
The function prototype of ==abs()==, available in the standard C library as our previous examples, looks as follows:

[[[
int abs ( int n );
]]]

To create a binding for such a function requires that we somehow provide an ==n== argument in our binding.
To ease argument bindings, uFFI automatically matches the parameter names in our methods to the corresponding function parameters, if they have the same name.
In other words, we can define our binding for ==abs()== as a method with a single ==n== argument as follows:

[[[language=smalltalk
FFITutorial class >> abs: n [
	^ self ffiCall: #( int abs (int n) )
]
]]]

Creating this binding does not really add any extra complexity to the ones done in previous examples.
We create a simple method using the ==ffiCall:== message, and we provide as argument an array with a copy of the function's prototype.
The only visible addition is the introduction of the ==n== parameter, but no manual work was required to transform Pharo's object to a C value.
We can even rename that parameter using a more Pharoish style, let's say ==anInteger==.

[[[language=smalltalk
FFITutorial class >> abs: anInteger [
	^ self ffiCall: #( int abs (int anInteger) )
]
]]]

Finally, we can now use this binding from a playground as follows, with a regular Pharo SmallInteger.

[[[language=smalltalk
FFITutorial abs: -42.
]]]

!!! Marshalling

Again, it was uFFI that managed value transformations for us.
This transformation may look like uFFI simply copies the Pharo integer value to the C memory.
However, these marshalling rules are not as straight forward, as Pharo and C use different data representations for each different data-type, and is potentially modified per platform.

To illustrate how marshalling works, let's consider the marshalling of a SmallInteger to a C ==int== type as in the example.
Internally, to differentiate integers from object pointers, Pharo represents SmallIntegers with an extra bit tagging the value.
Let's consider the SmallInteger 2, represented in binary as the number 10, and is internally represented by Pharo as 101.
This ''representation mismatch'' requires that uFFI transforms small integers to C ==int==s as follows:
- a Pharo small integer transformed in a C value needs to be shifted to the right, ==101 >> 1==, transforming 101 to 10.
- a C integer transformed in a Pharo small integer needs to be shifted to the left and added 1, ==(10 << 1) + 1==, transforming 10 to 101.

!!!! Pharo-to-C Marshalling

When marshalling Pharo objects to C, uFFI decides the rule of marshalling to use depending on two pieces of information.
On the one hand, it uses the concrete type of the marshalled object ''its class''.
On the other hand, it uses the type defined in the function binding as the target transformation type.
At run time, when the binding method is executed, uFFI takes the type of the binding argument and transforms the argument object to the C representation of that type, doing a ''cast'' if necessary. This transformation rules has several consequences, that we will illustrate in several cases using our running ==abs== example:

- SmallIntegers are transformed to ==int==s as expected.

[[[language=smalltalk
FFITutorial abs: -42.
=> 42
]]]

- Integers that overflow the ==int== size are casted/cut down, producing results similar to what a C program would produce.

[[[language=smalltalk
FFITutorial abs: SmallInteger maxVal.
=> 1
]]]

- Floats used for ==int==s will be automatically casted and only their integer part retained

[[[language=smalltalk
FFITutorial abs: Float pi.
=> 3
]]]

- Objects non compatible with the ==int== type are rejected and an exception is thrown

[[[language=smalltalk
FFITutorial abs: Object new.
=> exception!
]]]

!!!! C-to-Pharo Marshalling

A similar-yet-different story happens when marshalling C values to Pharo objects.
In this case uFFI decides the rule of marshalling depending on just the specified return type.
At run time, when the binding method is executed and the function returns, uFFI transforms the returned value to the closest Pharo type for the specified C type.
For example, the ==int== type will interpret the returned data as SmallIntegers or Positive/Negative/LargeIntegers depending on their size and sign,
the ==float== type will interpret the returned data as Float.

!!!! Marshalling of Incorrect Types

The marshalling rules we have seen above show that the way in which we specify function types is crucial to the correct behaviour of our bindings, and thus our applications.
In other words, bindings require that types are correctly specified, runtime errors, or even worse, incorrect value transformation may happen.
Let's consider as an example what happens if we modify the signature of the ==abs== function to use a ==float== as argument.

[[[language=smalltalk
FFITutorial class >> floatAbs: aFloat [
	^ self ffiCall: #( int abs (float aFloat) )
]
]]]

And then we evaluate in a playground our binding with a negative float value:

[[[language=smalltalk
FFITutorial floatAbs: -1.0.
=> 0
]]]

Although we expected the message to return 1 (because the return value is still of type ==int==), this example returns 0.
To understand this result, we need to first understand that our bindings are independent of the actual function we are calling.
This means, even if we set the type of ==abs== as ==float== the ==abs== function in our system was built and compiled to work on ==int== values.
So what happens under the hoods in this example is that uFFI transforms our -1.0 Pharo float to a C float, and then uses that value as if it was an integer.
This may have hillarious results.

A similar problem arises if the return type of a function is incorrectly specified.
Let's take for example a slightly modified version of our ==abs== binding for float return types:

[[[language=smalltalk
FFITutorial class >> floatReturnAbs: anInteger [
	^ self ffiCall: #( float abs (int anInteger) )
]
]]]

Whenever this function returns, it will interpret the returned value as a float.
However, as the actual implementation of ==abs== returns an ==int==, the integer is just wrongly interpreted producing strange values.

[[[language=smalltalk
FFITutorial floatReturnAbs: Float pi.
=> 3.3702805504e12
]]]

!!! Literal Arguments

Imagine that we want to have a wrapper that always calls the ==abs== function with the number -42.
Then we directly define it as follows:

[[[language=smalltalk
FFICExamples class >> absMinusFortyTwo [
	^ self ffiCall: #( int abs (-42) ) module: LibC
]
]]]

Note that we omitted the type of the argument and directly write  ==int abs (-42)== instead of writing
==int abs (int -42)== since by default arguments are automatically converted to C int.

But, if the C function takes a float/double as argument for example, you must specify it in the signature:

[[[language=smalltalk
FFICExamples class >> floor: aFloat [
	^ self ffiCall: #( double floor(double aFloat) ) module: LibC
]
]]]

@@todo Luc Examples with more complex literals: arrays, ...

!!! Passing variables

Often some functions in C libraries take flags as arguments whose values are declared using #define in C headers.
You can, of course take these constant values from header and put them into your callout.
But it is preferable to use a symbolic names for constants, which is much less confusing than just bare numbers.
To use a symbolic constant you can create an instance-variable, a class-variable or a variable in shared pool, and
then use the variable name as an argument in your callout.

For example, imagine that we always pass a constant value to our function that is stored in a class variable of our class:

[[[language=smalltalk
Object subclass: #FFICContantExamples
	...
	classVariables: 'TheAnswer'
..
]]]

Then don't forget to initialize it properly:

[[[language=smalltalk
FFICContantExamples class >> initialize [
	TheAnswer := -42.
]
]]]

And finally, in the callout code, we can use it like following:

[[[language=smalltalk
FFICContantExamples class >> absMinusFortyTwo [
	^ self ffiCall: #( int abs ( TheAnswer ) ) module: LibC
]
]]]

You can also pass ==self== or any instance variable as arguments to a C call.
Suppose you want to add the ==abs== function binding to the class ==SmallInteger== in a method named  ==absoluteValue==, so that we can execute ==-50 absoluteValue==.

In that case we simply add the ==absoluteValue== method to ==SmallInteger==, and we directly pass ==self== as illustrated below.

[[[language=smalltalk
SmallInteger >> absoluteValue [
	^ self ffiCall: #( int abs (int self) ) module: LibC
]
]]]

It is is also possible to pass an instance variable, but we let you do it as an exercise :)

!!! Passing strings

As you may know strings in C are sequences of characters terminated with a special character: ==\\0==.
It is then interesting to see how FFI-NB deals with them since they are an important data structure in C.
For this, we will call the very well known ==strlen== function.
This function requires a string as argument and returns its number of characters.

""C header"".
[[[
int strlen ( const char * str );
]]]

""Smalltalk binding"".
[[[language=smalltalk
FFICExamples class >> stringLength: aString [
	^ self ffiCall: #( int strlen (String aString) ) module: LibC
]
]]]



!!! Example analysis

You may have noticed that the callout description is not exactly the same as the C function header.

In the signature ==#( int strlen (String aString) )== there are two differences with the C signature.
- The first difference is the const keyword of the argument. For those not used to C, that's only a modifier keyword that the compiler takes into account to make some static validations at compile time. It has no value when describing the signature for calling a function at runtime.
- The second difference, an important one, is the specification of the argument. It is declared as ==String aString== instead of ==char * aString==. With ==String aString==, FFI-NB will automatically do the arguments conversion from Smalltalk strings to C strings (null terminated). Therefore it is important to use String and not ==char *==. In the example, the string passed will be put in an external C ==char== array and a null termination character will be added to it. Also, this array will be automatically released after the call ends. This automatic memory management is very useful but we can also control it as we will see later. Using ==(String aString)== is equivalent to ==(someString copyWith: (Character value:0)== as in ==FFICExamples stringLength: (someString copyWith: (Character value:0)==. Conversely, FFI-NB will take the C result value of calling the C function and convert it to a proper Smalltalk Integer in this particular case.

!!! Passing two strings

We will now call the ==strcmp== function, which takes two strings as arguments and returns -1, 0 or 1 depending on
the relationship between both strings.

""C header""
[[[
	int strcmp ( const char * str1, const char * str2 );
]]]

""Smalltalk binding""
[[[language=smalltalk
FFICExamples class >> stringCompare: aString with: anotherString [
	^ self ffiCall: #( int strcmp (String aString, String anotherString) ) module: LibC	
]
]]]

Notice that you can add arguments by appending them to the arguments array, using a comma to separate them. Also
notice that you have to explicitly tell which object is going to be sent for each argument, as already told. In this
case, aString is the first one and anotherString is the second one.

!!! Getting return value from a function

Symmetrically to arguments, returned values are also marshalled, it means that C values are converted to Smalltalk objects.

We already saw that implicitly through multiple examples since the beginning of the chapter.
For example in the ==abs== example, the result is converted from an int to a SmallInteger.
In the ==floor== example, the  result is converted from a double to a Float.

But FFI-NB can also convert types a bit more complex than atomic types, like String

[[[language=smalltalk
FFICExamples >> #getEnv: aString [
	^ self ffiCall: #( String getenv (String string) ) module: LibC
]
]]]

There is a mapping defined for each atomic type. About a bit more complex objects (like external objects or structures),
we will talk in following sections.

!!! Returning "void *"

Take this call as an example:

[[[language=smalltalk
FFICExamples class >> malloc: aNumber [
	^ self ffiCall: #( void * malloc ( int aNumber ) )
]
]]]

This is a special case of return: when there is a function who answers a ''void *''. In this case, since FFI-NB cannot know
which kind of object it represents, it will answer an instance of ==ExternalData== (we will see this in next section).

@@todo Luc illustrate that when NULL (a pointer with value 0) is returned, it is automatically converted to nil