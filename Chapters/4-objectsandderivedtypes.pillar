!! Designing with uFFI and FFI Objects

In addition, uFFI allows developers to define their own user-defined data-types in Pharo.
User-defined data-types range from simple type aliases, to user-defined classes wrapping external C values.

!!! External objects

==FFIExternalObject== represents an object in the heap. An external object is a reference to any kind of data allocated in the heap mapped to a Smalltalk object.

This is confusing, so I will try to explain it better: When you allocate a region of memory in the heap, you get a pointer to that location, which does not represent anything. But often, frameworks will allocate structures, pointers, etc. which actually represents "an object" (not in the same sense as a Smalltalk object, but can be interpreted like one). For example,
to create a cairo surface, you can call this:

[[[
AthensCairoSurface class >> primImage: aFormat width: aWidth height: aHeight [
	^ self ffiCall: #(AthensCairoSurface * cairo_image_surface_create ( int aFormat,
	int aWidth, int aHeight) )
]
]]]

This will call the cairo function ==cairo_image_surface_create== but instead answer an ==ExternalAddress== it will create an
instance of ==AthensCairoSurface==, so you can treat the allocated pointer as an object.

Any class in the system can be an external object as long as either:
- it inherits from ==FFIExternalObject==; or
- it implements in its ""class side"" the method ==asExternalTypeOn:==.

You can check for implementors of ==asExternalTypeOn:== for examples, but they usually looks like this one:

[[[
AthensCairoCanvas class >> asExternalTypeOn: generator [
	"use handle ivar to hold my instance (cairo_t)"
	^ FFIExternalObjectType objectClass: self
]
]]]

@@note if you want to add the resource to an automatic free mechanism (to make GC frees also the external object), you need
to call ==autoRelease== (in case of children from FFIExternalObject) or implement similar mechanism.

@@note FFIExternalObject replaces NBExternalObject

!!! Opaque references
UnifiedFFI can work with opaque types (An opaque datatype is an structure which fields are not visible and is always accessed through a pointer 
to it, see *https://en.wikipedia.org/wiki/Opaque_data_type*).
This is usefull when working with obscure types (types we do not know its composition).
Take this as an example (taken from SQLite bindings): 

[[[ 
typedef struct sqlite3 sqlite3;
typedef struct sqlite3_stmt sqlite3_stmt;
]]]

this defines a type of a structure, and then is used along the api in this way: 

[[[
int sqlite3_open(char *filename, sqlite3 **handle);
char *sqlite3_column_name(sqlite3_stmt* aStatement, int aColumn)
]]]

this means we always access them through a reference. Now, we could declare the pointer to the structures (using ==FFIExternalObject==), 
but then our declarations wouldn't be as close to C as we want, as we need to change the declaration.

This is where ==FFIOpaqueObject== come to help: we declare it and then we use it always as reference.

In the case of the example, it would work like this: 

[[[ 
SQLite3 class >> initialize [
	sqlite3 := #FFIOpaqueObject.
	sqlite3_stmt :=	#FFIOpaqueObject.
]

SQLite3 class >> primOpen: filename handle: handle [
	self ffiCall: #(int sqlite3_open(String filename, sqlite3 **handle)).
]

SQLite3 >> primColumnBlob: aStatement column: aColumn [
	self ffiCall: #(const void *sqlite3_column_blob (sqlite3_stmt* aStatement, int aColumn))
]
]]]

!!! External address

External addresses (contained in the class ==ExternalAddress==) is the way we represent any kind of data ''outside''
Smalltalk. That means data (pointers, structures, arrays) who are allocated in the heap.

An ==ExternalAddress== can be:

- an allocation of memory (you can use ==ExternalAddress class >> allocate:== or ==ExternalAddress class >> gcallocate:==). Note that in case of ==#allocate:== you will need to ==#free== the external address later (==#gcallocate:== does that work for you).
- the result of a function call (usually it will come as part of an ==ExternalData==)

==ExternalData== represents an ==ExternalAddress== with an C type associated. For example,

Both ==ExternalAddress== and ==ExternalData== can be used as arguments when declaring functions with pointers as parameters,
for example:

[[[
LibC >> memCopy: src to: dest size: n [
	^ self ffiCall: #(void *memcpy(void *dest, const void *src, size_t n)
]
]]]

!!! Handles (Windows)
Constant HANDLEs, as described in *Windows MSDN>https://msdn.microsoft.com/en-us/library/windows/desktop/ms724457(v=vs.85).aspx*
are a special kind of external object who are accessed through numbers, therefore and ==ExternalAddress== is not appropriate to 
describe it (since they are constants and external addresses represents disposable spaces from memory).

Is not clear this is necessary outside Windows, but according to documentation they are somekind analogous to unix's File Descriptors 
(with some remarkable diferences, as documented *here>http://lackingrhoticity.blogspot.fr/2015/05/passing-fds-handles-between-processes.html*.

Example: 
[[[
User32 class >> initialize [
	HWND := #FFIConstantHandle.
]

User32 class >> getActiveWindow [
	^ self ffiCall: #(HWND GetActiveWindow())
]
]]]

!!! Annexes


!!!! Casting 
In Pharo, “casting” as made in C is not necessar since this is just a way to tell the C compiler that a pointer is form a certain 
type (but is always a pointer, and in machine code is always the same). Nevertheless, there are some usages were we may want to see 
pointers as specific instances in our image. 
Next examples will cover this cases.

!!!!! Converting pointers to objects of any type
So, here you will do something like this: 

Let's suppose you want to execute something like this (taken from a question on the pharo mailing list): 

[[[
Iterator >> asCollectionOfType: aTypeName [
	| result address typeClass |
	
	result := OrderedCollection new.
	address := ExternalAddress new.
	typeClass := FFIExternalType resolveType: aTypeName.
	[ self iterator_next: address ] 
		whileTrue: [ result add: (address castTo: typeClass) ].
  ^result
 ]

Iterator >> iterator_next: data [
	^ self ffiCall: #(Boolean iterator_next (Iterator self, void** data))
]
]]]


This is, you want to iterate a collection of certain type and converting it to proper instances on Pharo side. 

While you could always implement ==#castTo:== simply like this: 

[[[
ExternalAddress >> castTo: aClass [
	^ aClass fromHandle: self
]
]]]

But you will still have a problem if your type if your type is an “atomic” type, like ==int==, ==long==, etc. because those values are passed 
“by value” and not by pointer, so you will need to decode them. In this case, I would implement a method extension and use double dispatch: 

[[[
ExternalAddress >> castTo: aClass [
	^ aClass valueFromHandle: self
]

FFIExternalType class >> valueFromHandle: anAddress [
	“This is used for structures, but we can reuse them :)"
	^ self new handle: anAddress at: 1 
]
		
FFIExternalReference class >> valueFromHandle: anAddress [
	^ self fromHandle: anAddress
]

FFIExternalStructure class >> valueFromHandle: anAddress [
	^ self fromHandle: anAddress
]
]]]

Then your cast will work as expected.

!!!!! Non conventional casts
Casting in C is trivial. You can do something like this:

[[[
void *var = 0x42000000.
]]]

And you will be creating a pointer who points to the address 0x42000000. This kind of declarations are used in certain frameworks, notably some Windows libraries.

In Pharo this "casting" is not so easy, and we need to declare this kind of variables as ExternalAddresses. We do this as this:

[[[
var := ExternalAddress fromAddress: 16r42000000.
]]]

!! FAQs

If someone is interested to collect questions and answers from the mailing-list this is where there could go. 