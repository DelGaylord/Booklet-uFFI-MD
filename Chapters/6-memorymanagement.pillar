!! uFFI and memory management

Using uFFI requires developers to be concious about how memory is managed, because differently than C, Pharo is a garbage collected language.
On the one hand, most C libraries will require users to make manual bookeeping of the memory they use by explicitly allocating or de-allocating memory.
On the other hand, Pharo will automatically reclaim unused Pharo objects, or move them in the memory if so is required.

Binding developers need to be extra careful when design their bindings to manage these differences.
Failing to do so will produce many funny effects such as memory leaks that are hard to detect and incorrect memory accesses.

In this chapter we re-visit how external objects are allocated (and de-allocated) in both the Pharo and the C memory.
We see the case of Pharo objects sent by reference to C libraries, and we introduce the concept of ""pinned objects"": objects that are not be moved by the garbage collector, yet are still garbage collected.
Finally, we introduce uFFI auto-released objects: Pharo external objects that will automatically release their C counterpart when they are garbage collected.


!!! Pharo vs C memory management: the basics

Memory in Pharo and in C is managed in fundamentally different ways.
Pharo has automatic memory management where a garbage collector tracks used-objects, moves them around and periodically reclaims unused objects.
C requires developers to manually manage their memory.
This section introduces the difference between these two models, and finally introduces the subtleties of uFFI external objects which allow both of them.

!!!! Memory in C

C programs organize their usage of memory in three different ways: static, automatic and dynamic memory.
Static memory is memory allocated when the process starts and not released until the process finishes.
How much memory to allocate is known before the execution, typically calculated at compile time.
For example, ==static== variable declarations in a C program tell the compiler how much memory to pre-allocate for them.

[[[language=c
static int pre_allocated_variable = 5;
]]]

Automatic memory is the memory allocated and released without explicit developer intervention.
For example, space for the local variables of functions is automatically allocated when functions are called, and released when functions return.
Automatic memory is generally managed by the ==stack==, i.e., extra space is allocated in the stack on a function call, and automatically released on function return because the extra space is popped from the stack to come back to the caller function.
How much extra memory has to be allocated in the stack is generally calculated at compile time.

[[[language=c
void some_function(){
  // Automatic variable allocated in the stack
  int t = 42;
}
]]]

Finally, dynamic memory is the memory that cannot be statically calculated, so programs explicitly allocate and reclaim it.
Dynamic memory is manipulated through system libraries, for example with the functions ==malloc== and ==free==.
This kind of memory is said to be stored in the ""heap"", since the memory allocated by the system is usually organized with a heap data-structure.
Memory dynamically allocated needs to be manually released, otherwise provoking potential memory leaks. 

[[[language=c
  //Allocate 17 bytes and grab a pointer to that memory region
  int* pointer = (int*)malloc(17);
  //Free that memory
  free(pointer);
]]]

!!!! Objects in the Pharo Heap

Pharo programs feature automatic memory management: all objects need to be explicitly allocated, and are automatically reclaimed by a garbage collector when they are not used anymore.
Objects are allocated in Pharo by sending the ==#new== and ==#new:== messages to a class.
Although there are several kind of classes in Pharo, for the purpose of this booklet we will concentrate on the two main kind of classes: fixed-size and variable-size classes.
Fixed-size classes are classes with a fixed number of instance variables, instantiated with the message ==#new==.
When the VM is instructed to instantiate one of these classes, it calculates the amount of memory required for the instance by looking at the class' instance variables.
This is the case of most of the classes we create ourselves.
For example, class ==Point== is a fixed-size class with two instance variables ==x== and ==y==.

[[[language=smalltalk
Object subclass: #Point
  instanceVariableNames: 'x y'
  classVariableNames: ''
  package: 'Kernel-BasicObjects'
    
Point new
]]]

Variable-size classes are classes whose instances have variable size.
For example, the ==Array== class allows instances with 0 or many slots.
These classes are instantiated through the ==#new: aSize== message, specifying the number of required slots at instantiation-time.

[[[language=smalltalk
ArrayedCollection variableSubclass: #Array
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'Collections-Sequenceable-Base'
    
Array new: 20.
]]]

In contrast with C-managed memory,once instantiated, the life-cycle of a Pharo object is automatically managed by the virtual machine. For the purposes of this uFFI booklet, it is important to know two main properties of Pharo's garbage collector:
1. the storage of an object that is not used anymore will be automatically reclaimed;
2. the position of an object may change during execution to avoid memory fragmentation.
Although these two properties are nice from a Pharo perspective, they require special attention for a uFFI developer, as she has a foot on the Pharo world and a foot in the C world.
We will see in the following section how these properties affect programming with uFFI, and how Pharo and uFFI provide support to minimize the impact of these issues through auto-release and pinning.

!!! uFFI external objects in the C Heap

!!!! Instantiation in the C Heap

!!!! Memory leaks

!!! The uFFI auto-release mechanism

Sending #autoRelease message of an object registers object for finalisation with a particular executor.
Then behaviour is divided:

-A.1) for ExternalAddresses, it just registers in regular way, who will call ==finaliz==e on GC
-A.2) finalize will just call a free assuming ExternalAddress was allocated (which is a malloc)

- B.1) for all FFIExternalReference, it will register for finalisation what ==resourceData== answers (normally, the handle of the object)
- B.2) finalisation process will call the object class >> finalizeResourceData: method, with the==resourceData== result as parameter
- B.3) each kind of external reference can decide how to free that data (by default is also just freeing).

An example of this is how AthensCairoSurface works.

@@todo add an example

!!! uFFI external objects in the Pharo Heap

We have seen in previous chapters that the different kind of external objects such as structures, arrays or unions, can be instantiated as normal objects using the ==#new== message.
This makes external objects to be allocated in the Pharo heap.

[[[language=smalltalk
myStructure := MyStructure new.
]]]

Allocating in the Pharo heap has a main advantage: we do not need to manually track the life-cycle of the object and use functions like C's ==free()== to manually release it.
Instead, the object and the storage it occupies will be released automatically by the garbage collector as soon as our Pharo program does not use it anymore, just like any other Pharo object.

[[[language=smalltalk
myStructure := MyStructure new.
" ... use my structure ... "
" nil it and PLUF, eventually the object will be discarded "
myStructure := nil.
]]]

However, as objects in the Pharo heap and subject to the control of Pharo's garbage collector, the garbage collector can then wrongly decide to collect objects that, seemingly unused from Pharo, are used from a C library, or decide to move it, leaving a dangling pointer in the C library.
This situation leads to memory corruptions and funny bugs.

!!!! Moving objects and pinned objects

As soon as we send an external object as the argument of a C function, the C function has the freedom to manipulate that external object as it pleases. In particular, this can present some troubles when we send the object by reference using a pointer type, as illustrated in the following function binding:

[[[language=smalltalk
FFITutorial >> myFunction: aStructure [
  ^ self ffiCall: #(void myFunction(MyStructure* aStructure))
]
]]]

This poses the problem of ''moving objects''.
Sending a Pharo-allocated external object by reference sends the ''address'' of that object to the function.
The garbage collector can then decide to move that object in memory and change its address.
However, since the garbage collector has no knowledge about the C library, it cannot determine how that address is used and it cannot update it.
Moreover, there are no guarantees that concurrently the garbage collector and the C library access and modify the address at the same time.
We will see in a future chapter that multi-threaded FFI weakens such guarantees even more.

To cope with the problem of moving objects, the Pharo runtime supports ''pinned'' objects.
Pinned objects are objects that can be reclaimed but not moved by the garbage collector, avoiding the problem of ''moving objects''. To pin an object in memory, we can use the message ==#pinInMemory==.

[[[language=smalltalk
myStructure := MyStructure new.
myStructure pinInMemory.
" ... use safely my structure ... "
" nil it and PLUF, eventually the object will be discarded "
myStructure := nil.
]]]

If eventually we decide to unpin the object, we can do so by using ==#unpinInMemory==.

[[[language=smalltalk
myStructure unpinInMemory.
]]]

For more fine grained control, external object also support the messages ==isPinnedInMemory== and ==setPinnedInMemory: aBoolean==. The former returns a boolean specifying wheter the object is pinned or not.
The latter allows changing the pinned property with a boolean.

@@note Remember that pinning objects in memory do not prevent the garbage collector to reclaim those objects.
Any pinned yet unused object will be garbage collect and may create memory corruptions too.