!! Foreign Function Interface and Call-Outs

A Foreign Function Interface (FFI) is a programming language mechanism that allows software written in one language to use resources (functions and data structures) that were written in and compiled with a different language.  These "foreign" resources typically take the form of shared libraries, such as DLL files in Windows (or '.so' files in Linux and Mac) and can include run-time services made available by your operating system.  A good example is a driver provided by a vendor of a computer peripheral, such as a printer or a network card.

Code sharing and reuse via an FFI is fundamentally different from source code "includes", calls to IDE libraries, or messages sent to the base classes provided by your language's development environment.  In those cases, your compiler can link function calls and share structured data while making convenient assumptions about the object code interface (known as the ABI, or Application Binary Interface).  This is familiar programming: We follow published APIs (Application Programming Interfaces) as we write our code, and the compiler takes care of the low-level connections for us transparently.

However, if the compiled resources we wish to link to were built with a different language (or even a different compiler of the same language), the bits and bytes may not line up properly when we push arguments, make calls, and retrieve results, due to the different standards that the other code's compiler followed when the borrowed code was produced.  In this case, more detailed bookkeeping must be followed by our language to make ABI translations and ensure that differences in issues such as data alignment, byte ordering, calling conventions, garbage collection, pointer references, and so forth are accounted for.  Without this, we risk not only getting incorrect results -- we could crash our process (or even the operating system).

Although in theory FFI interfaces can be defined to link any pair of differing languages, most languages are designed to interact with libraries written in the C language.  This is because C has a long heritage and widespread use, and (importantly) C has a predictable, standardized way to compile functions and structures.  So with Pharo also choosing C as an FFI target we gain two major advantages: first, by basing ourselves on such "standard" formats, we can build tools that simplify interoperability with an extensive array of existing C libraries.  Second, since nearly every other language is doing the same, we can simply join those mutual C-standard ABIs together to form a bridge between different systems -- allowing us to program at the source level of a C API.

This booklet shows one such FFI definition for Pharo: the Unified FFI framework, or uFFI for short.

The Pharo uFFI is an API framework that eases communication between Pharo code and code that follows a C-style interface, making it possible to easily interact with external C libraries.  Given that 'calling functions' is the ultimate objective of someone using an FFI, you will see that uFFI also helps with several other concerns, such as finding C function interfaces, transforming data between the Pharo world and the C world, accessing C structures, defining C-to-Pharo callbacks, and others.

Pharo uFFI has been developed by E. Lorenzano, and has received many contributions over the years from Pharo's open source community.

!!! Calling a simple external function

To illustrate the purpose and usage of uFFI, we will start with an example.
Suppose we want to know the amount of time the image has been running by calling the underlying OS function
named ==clock==. This function is part of the standard C library (==libc==). Its declaration in C is:

[[[
clock_t clock( void );
]]]

For the sake of simplicity, let's treat ==clock=='s return type as an unsigned ==uint== instead of ==clock\_t==.
(We will discuss types, conversions, and typedefs in subsequent sections.)
This results in the following C function declaration:

[[[
uint clock( void )
]]]

To call ==clock== from Pharo using uFFI, we need to define a binding between a Pharo method and the ==clock== function.
FFI bindings are classes and methods that provide an object-oriented style to access the C world, implementing all the glue required between the Pharo world and the C world.

To write our first binding, let's start by defining a new class, ==FFITutorial==.
This class will act as a module and encapsulate not only the functions we want to call but also any state we would like to persist.
To access the ==clock== function, we then define a method in our ==FFITutorial== class using the ==ffiCall:module:== message to specify the declaration of the C function and indicate where it is defined. We will technically refer to this binding as a ''call-out'', since it ''calls'' a function in the ''outside'' world (the C world).

If we are hosted on a Linux system, we define this class and method like so:

[[[language=smalltalk
Object subclass: #FFITutorial
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'FFITutorial'

FFITutorial class >> ticksSinceStart [
  ^ self ffiCall: #( uint clock () ) module: 'libc.so.6'
]
]]]

where =='libc.so.6'== refers to the current version of the C shared library on our host system.  (We can find out which version we have by entering ==ls -1 /lib/*/libc.so*== in a Linux terminal window.)

To define the same thing on other platforms, we need to replace the =='libc.so.6'== string by e.g., =='libc.dylib'== if we're running on OSX, or =='msvcrt.dll'== if we use Windows. The equivalent definitions for OSX and Windows are then:

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
  ^ self ffiCall: #( uint clock () ) module: 'libc.dylib'
]
]]]

and

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
  ^ self ffiCall: #( uint clock () ) module: 'msvcrt.dll'
]
]]]

Finally, we can use our freshly-created bindings in a Pharo playground by inspecting or printing the following expression:

[[[language=smalltalk
FFITutorial ticksSinceStart
]]]

If everything works as expected, this expression will return the number of native clock ticks since our Pharo process was launched.

!!! Analyzing the FFI Call-Out

The simple example we ran in the previous section illustrates several important uFFI concepts.
For starters, let's look at the binding definition again:

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
	^ self ffiCall: #( uint clock () ) module: 'libc.so.6'
]
]]]

This call-out binding, a Pharo method, is called ==ticksSinceStart== and happens to be named differently than the C function we are calling.
Indeed, uFFI does not impose any restrictions as far as how to call your external functions.  This can come in handy for decoupling your methods from underlying C-level implementation details.

We invoke the C function using the Pharo method ==ffiCall:module:==, which is defined by uFFI.  We assemble the message arguments it needs by deconstructing the target C function declaration and referencing the name of the library in which it's defined.  uFFI takes the pieces and performs all the necessary work to make the call-out.  Continuing our example, we see that uFFI:
- Locates the specified library (==libc==, ==msvcrt==, ...) in our host system,
- Loads the C library into memory,
- Indexes the ==clock== function in the library,
- Transforms and pushes our Pharo arguments onto the stack,
- Performs the call to the C function,
- And finally transforms the return value (==uint== type) into a Pharo integer object.

We said above that we need to "deconstruct" the C function declaration in order to create the first argument in our ==ffiCall:module:== message.  This argument is a Pharo Array of String, where each string element is a piece of the C declaration; we simply list the pieces in the same sequence as the C declaration.  The uFFI makes sense of it, and dynamically creates a C call with this information.

This is best understood by example, so, to continue with our previous example, we render our C declaration in Pharo as:

[[[
#( uint clock () )
]]]

The first element of our array is ==unit==, which is the function return ''type''.  This is followed by the function name, ==clock==.  Following the function name --and note the space!-- we embed another Pharo Array to list the formal arguments the C function expects, in order. In this case, ==clock== takes no arguments, so we must provide an empty Array.

Another way to think of it is this: If we look past the outer ==#()== Pharo syntax, what we see inside is our C function prototype, appearing very similar to normal C syntax (but with spaces in unusual places).  uFFI was intentionally defined this way so that in most cases we can simply copy-paste a C function declaration taken from a header file or documentation, add some required spaces, wrap it in ==#()==, and it's ready for use.

Our ==ffiCall:module:== message also takes a second argument (=='libc.so.6'== in our Linux example), which is the name of the library that contains the function.  In many cases we do not need to provide a full path to the file in our host system.  However, it should already be apparent that our bindings can be platform dependent, if the library we need is also platform-dependent.  We will explore how to define bindings in a platform-independent way in the following section.


!!! Notes on Value Marshalling

To fully understand the previous example, the last thing we need to explain is how the returned ==uint== value gets transformed into a Pharo ==SmallInteger==.
This conversion of values between different languages is called ''marshalling'', and is in most cases managed automatically by uFFI.
Indeed, uFFI internally maps standard C values to Smalltalk objects, for example:
- types ==int==, ==uint==, ==long==, ==ulong== are mapped to Pharo integers (small or long integers depending on the size of the platform).
- types ==float== and ==double== are mapped to Pharo floats.

Value marshalling is crucial for a correct behaviour of the bindings, particularly because the C world is closely-tied to the underlying machine.
Indeed, C values are bits and bytes in registers and memory, and can be interpreted in many different ways by the Pharo runtime.
For example, the C integer value 0x00000000 can be the interpreterd as the small integer 0, as the ''false'' object or as a null pointer depending on the marshalling rules.
This means that the binding developer needs to correctly describe the types of their bindings so uFFI correctly interprets and transforms those values.

In following chapters we will explore the marshalling rules more in detail and how they apply not only for return values but also for arguments.
Moreover, we will study how to define your own user-defined data types and type mappings, to customize the marshalling for your special needs.

!!! Libraries

We saw before that a call-out binding requires us to specify a module or library, which uFFI uses to look-up the given function.
In our previous example, we defined that the ==clock== function was inside the standard C library, i.e., ==libc.so.6== in a unix system.
However, this solution was not portable enough: if we want to load and run this code in a different platform, we needed to change the library name to match our local system.
Library will not necessarily have the same name, or be located in the same place, on all platforms.
One way to overcome this issue would be to define a binding per platform, and decide which one to call based on the platform as follows.

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
  self platform isWindows
    ifTrue: [ ^ self ticksSinceStartWindows ].
  self platform isUnix
    ifTrue: [ ^ self ticksSinceStartUnix ].
  self platform isOSX
    ifTrue: [ ^ self ticksSinceStartOSX ].
  self error: 'Non supported platform'
]

FFITutorial class >> ticksSinceStartUnix [
  ^ self ffiCall: #( uint clock () ) module: 'libc.so.6'
]

FFITutorial class >> ticksSinceStartOSX [
  ^ self ffiCall: #( uint clock () ) module: 'libc.dylib'
]

FFITutorial class >> ticksSinceStartWindows [
  ^ self ffiCall: #( uint clock () ) module: 'msvcrt.dll'
]
]]]

This means that the binding code is repeated three times, and changing the binding now requires changing three bindings.
This still looks simple enough for our ==clock== binding but repeating the code of complex bindings may not be an optimal solution.
uFFI solves this problem by using library objects instead of plain strings.
A library object represents a library independently of its platform as an instance of ==FFILibrary==.
This library defines methods ==macModuleName==, ==unixModuleName== and ==win32ModuleName== which uFFI queries to lookup the correct library name given the current platform.
Such lookup can even be as complex as dynamically looking for a correct version of library in different directories in your system as we will see later on.
For our example, we can define a library ==MyLibC== as follows.

[[[language=smalltalk
FFILibrary subclass: #MyLibC
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'UnifiedFFI-Libraries'

MyLibC >> macModuleName [
	^ 'libc.dylib'
]

MyLibC >> unixModuleName [
	^ 'libc.so.6'
]

MyLibC >> win32ModuleName [
	"While this is not a 'libc' properly, msvcrt has the functions we are defined here"
	^ 'msvcrt.dll'
]
]]]

Finally, we rewrite our binding to specify our library instead of the library name string.

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
	^ self ffiCall: #( uint clock () ) module: MyLibC
]
]]]

!!! Library Lookup

The ==macModuleName==, ==unixModuleName== and ==win32ModuleName== methods allow us developers to have different strategies to lookup for libraries and functions depending on the platform.
If these methods return a relative path, the libraries will be looked-up in common library directories in the system or close to the virtual machine executable.
If they return an absolute path, the default system locations are overriden and only the specified path will be checked for the library.
In both cases, if the library was not found or could not be loaded, it will raise an exception.
For example, an alternative definition for unix systems could have looked for the libc specifically in the ==/usr/lib/== directory.

[[[
MyLibC >> unixModuleName [
	^ '/usr/bin/libc.so.6'
]
]]]


Moreover, we are not constrained to simply return a string with a path.
Having a method allows us to define complex lookup rules, potentially looking up libraries dynamically.
To take a real example, let's consider how the cairo graphics library is defined for unix systems.
Although they are mostly compatible, Unix systems present from time to time different directory structures, specially to avoid mixing 32bit and 64bit libraries.
In the example below, the library lookup method for unix checks for the existens of the library in ==/usr/lib/i386-linux-gnu==, ==/usr/lib32== and ==/usr/lib==, and if found, it returns the absolute path to that file.

[[[language=smalltalk
CairoLibrary >> unixModuleName [
		"On different flavors of linux the path to library may differ
		depending on OS distro or whether system is 32 or 64 bit."

		#(
			'/usr/lib/i386-linux-gnu/libcairo.so.2'
			'/usr/lib32/libcairo.so.2'
			'/usr/lib/libcairo.so.2')
		do: [ :path |
			path asFileReference exists ifTrue: [ ^ path ] ].

		self error: 'Cannot locate cairo library. Please check if it installed on your system'
]
]]]

!!! Sharing Libraries Between Bindings

To finish this chapter, let's define a new binding to another function in the same library: ==time==.
The ==time== function receives a potentially null pointer and returns the current calendar time, which we will assume an ==uint== again for the time being for simplicity.
We can then specify our new binding as follows by providing a ==NULL== pointer as default argument.
We leave for the reader to lookup the definition of the function and the usefulness of the argument.

[[[language=smalltalk
FFITutorial class >> time [
	^ self ffiCall: #( uint time (NULL) ) module: MyLibC
]
]]]

This new binding uses the ==MyLibC== library we defined before, which introduces again some repeated code between our bindings.
To avoid repeating this information, we can extract it in a single method in our ==FFITutorial== class to be used by the two bindings.
This solution avoids making mistakes when defining libraries, though it is still not as neat as we would like.

[[[language=smalltalk
FFITutorial class >> myLibrary [
  ^ MyLibC
]

FFITutorial class >> ticksSinceStart [
	^ self ffiCall: #( uint clock () ) module: self myLibrary
]

FFITutorial class >> time [
	^ self ffiCall: #( uint time (NULL) ) module: self myLibrary
]
]]]

Further refactoring could clean this up, but fortunately to us, uFFI already provides support for sharing library definitions between bindings.
Any class defining a binding can also define a default library by redefining the ==ffiModuleName== method.
Then, we can omit at all the library definition in the call-out binding.
The library will be automatically be looked up by uFFI in the default definition.

[[[language=smalltalk
FFITutorial class >> ffiModuleName [
  ^ MyLibC
]

FFITutorial class >> ticksSinceStart [
	^ self ffiCall: #( uint clock () )
]

FFITutorial class >> time [
	^ self ffiCall: #( uint time (NULL) )
]
]]]

Of course, bindings defining a library explicitly override this mechanism, so you can create a class that has bindings mixing both mechanisms at your convenience.

!!! Conclusion

In this chapter we have seen the basics of FFI call-outs.
We declare a FFI binding to a function specifying the name of the function, its return type and the library this function belongs to.
uFFI uses this information to load the library in memory, lookup the function, call it, and marshall any C values to Pharo values and vice-versa.

[[[language=smalltalk
FFITutorial class >> ticksSinceStart [
	^ self ffiCall: #( uint clock () )
]
]]]

Since different platforms work differently, uFFI provides extensions to define a library as an object.
Library objects define per-platform strategies to lookup a library.
By specifying relative paths we let uFFI search for the library in well-known platform locations, while absolute paths override such behaviour.
Also, this mechanism allows binding developers to dynamically lookup a library in different places.

The next chapter covers function arguments in different flavours.
Although we ignored its details on purpose, the ==time== binding described in the previous version has a literal ==NULL== pointer argument.
We will see how literal arguments, which may be of different flavours, are very a convenient syntax sugar for setting default argument values.
They are not, however, the only means of sending data from Pharo to the C world, as we can also send Pharo objects.
Of course, precious care has to be taken when sending objects to the C world, so we will revisit marshalling more in detail.
