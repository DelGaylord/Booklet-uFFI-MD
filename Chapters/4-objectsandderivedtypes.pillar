!! Designing with uFFI and FFI Objects

In the previous chapters we have studied the uFFI mechanics necessary to bind an external C library.
We have studied in particular how to call functions, how basic types are marshalled, and how we can manipulate more complex types.
However, we have not yet discussed how those call\-out bindings and types should be structured in a project.

This chapter presents several ways to organize library bindings.
The first approach presented is the naïf-yet-simple ==single library object== that organises the bindings as a façade.
In addition, uFFI allows to take a second approach exploiting the object-oriented nature of Pharo, in particular splitting the binding in different objects and encapsulating the data they manipulate.
For this, we exploit the idea of ""external objects"" and ""opaque objects""

!!! First approach: single library façade object

The first approach for organizing external library bindings is to follow the façade design pattern.
In other words, there is a single object that concentrates all bindings and types of our library.
This approach is useful to have an idea of our bindings with a naked eye, since all bindings are together.

!!!! The ==FFILibrary== as a single point of access

uFFI proposes an idoneous place for such a pattern of usage: our library object, subclass of ==FFILibrary==.
We have seen in previous chapters that when defining a call\-out, we need to specify the external library where the function is located, either at the definition of the call\-out using the ==ffiCall:library:== method:

[[[language=smalltalk
FFITutorial >> abs: n [
  self ffiCall: #( int abs (int n) ) library: MyLibC
]
]]]

Or by omitting the library in the call\-out and redefining the method ==ffiLibrary== to specify the library for all call\-outs in the class.

[[[language=smalltalk
FFITutorial >> abs: n [
  self ffiCall: #( int abs (int n) )
]

FFITutorial >> ffiLibrary [
  ^ MyLibC
]
]]]

When we choose to use the façade pattern for our bindings, uFFI provides a convenience behaviour: for all subclasses of ==FFILibrary==, the method ==ffiLibrary== returns ==self==:

[[[language=smalltalk
FFILibrary >> ffiLibrary [
  ^ self
]
]]]

This convenience behaviour allows binding developers to place call\-out bindings inside the library object, and avoid declaring the ==ffiLibrary== at all.
By using this pattern, the library object is not only the object that knows how to find the external library and find the functions: it becomes also a reification of the external library with its functions too. 

!!!! Redefining ==MyLibC== as a façade

Following the pattern explained above, we can now turn our example library ==MyLibC== from the first chapter into a façade, as follows:

[[[language=smalltalk
FFILibrary subclass: #MyLibC
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'UnifiedFFI-Libraries'

MyLibC >> unixLibraryName [
	^ 'libc.so.6'
]

MyLibC >> macLibraryName [
	^ 'libc.dylib'
]

MyLibC >> win32LibraryName [
	"While this is not a proper 'libc', MSVCRT has the functions we need here."
	^ 'msvcrt.dll'
]

MyLibC >> ticksSinceStart [
	^ self ffiCall: #( uint clock() )
]

MyLibC >> time [
	^ self ffiCall: #( uint time( NULL ) )
]
]]]

Which can be used as any normal object now:

[[[language=smalltalk
MyLibC new time
]]]

We leave it as an exercise for the reader to explore the differences between putting the call\-out bindings as instance\-side or class\-side methods.

As the reader may see, this approach's is the strongest when we are binding a small library or a small subset of a large library.
The main advantage is that the entire binding can be understood by taking a look at a single class.
However, as soon as bindings grow in complexity, we need to re-structure and refactor our bindings into different objects, as we will see in the following sections.

!!! Extracting Behaviour into Objects

The ffi library façade object may become a big god object when the library we are binding is big or complex.
To cope with this inherent complexity, uFFI provides several mechanisms to extract FFI call\-outs into objects.
""External objects"" have special marshalling rules which combined with ==self== arguments allow us to desing nice object-oriented APIs.
Also, uFFI provides support for ""Opaque objects"", which are external objects whose internal implementation is not exposed by the ffi library.

!!!! External objects marshalling rules

External objects are uFFI objects representing objects from the external library.
We have already seen several external objects such as structures, unions and enumerations, which require creating subclasses of ==FFIStructure==, ==FFIUnion== or ==FFIEnumeration== respectively.
In the previous examples we have also seen that we can use objects of those types by using the class name as argument names.
This is possible because special marshalling rules exist for these objects:
- The instances of uFFI external objects are normal Pharo objects, which internally reference some C object through a ==handle==.
- When a uFFI external object is sent as argument, uFFI marshalls the external object to its ==handle==
- when a uFFI external object is expected as return value, uFFI assumes the function return value is a pointer and allocates the corresponding external object with that pointer as ==handle== 

Consider the example of the previous example that defines a fraction structure both in C:

[[[language=c
typedef struct
{
	int numerator;
	int denominator;
} fraction;

double fraction_to_double(fraction* a_fraction){
  return a_fraction -> numerator / (double)(a_fraction -> denominator);
}
]]]

And its uFFI binding:

[[[language=smalltalk
FFIStructure subclass: #FractionStructure
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'FFITutorial'

FractionStructure class >> fieldsDesc [
	^ #(
		int numerator;
		int denominator;
		)
]
]]]

!!!! Marshalling external object **arguments**: an example

As an example let's consider the ==fraction_to_double== from before and its usage below:

[[[language=smalltalk
FFITutorial >> fractionToDouble: aFraction [
  ^ self ffiCall: #(double fraction_to_double(FractionStructure* a_fraction))
]

FractionStructure rebuildFieldAccessors.
aFraction := FractionStructure externalNew.
aFraction numerator: 40.
aFraction denominator: 7.
FFITutorial new fractionToDouble: aFraction.
>>> 5.714285714285714
]]]

In the example above we see that the call\-out binding makes use of our defined type ==FractionStructure==.
However, when using this binding, we send as argument a fraction object, which is a normal Pharo object.
Using external object types as function arguments is actually a uFFI syntax sugar for the following (not so nice) binding.
This binding makes use of pointers with ==void*== argument types and breaks the encapsulation of our structure to access its internal handle, coupling itself with the internals of uFFI.

[[[language=smalltalk
FFITutorial >> fractionToDouble: aFraction [
  ^ self ffiCall: #(double fraction_to_double(void* a_fraction))
]

...
FFITutorial new fractionToDouble: aFraction handle.
>>> 5.714285714285714
]]]

!!!! Marshalling external object **return values**: an example

External object types can be used as return values of functions too.
Consider the following C function that creates a fraction struct and its uFFI binding.
Using ==FractionStructure== as return type of our binding, we tell uFFI to take the pointer returned from the function and create a ==FractionStructure== with that pointer as ==handle==.

[[[language=c
fraction* make_fraction(int numerator, int denominator){
  fraction* f = (fraction*)malloc(sizeof(fraction));
  f -> numerator = numerator;
  f -> denominator = denominator;
  return f;
}
]]]

[[[language=smalltalk
FFITutorial >> newFractionWithNumerator: numerator denominator: denominator [
  ^ self ffiCall: #(FractionStructure* make_fraction(int numerator, int denominator))
]

aFraction := FFITutorial new newFractionWithNumerator: 40 denominator: 7.
FFITutorial new fractionToDouble: aFraction.
>>> 5.714285714285714
]]]

As with arguments, external object return types is actually a uFFI syntax sugar for the following (again not so nice) binding.
This binding makes use of a pointer with ==void*== return type and manually initializes structure from it, coupling itself with the internals of uFFI.

[[[language=smalltalk
FFITutorial >> newFractionWithNumerator: numerator denominator: denominator [
  ^ self ffiCall: #(void* make_fraction(int numerator, int denominator))
]

aFraction := FractionStructure fromHandle: (FFITutorial new newFractionWithNumerator: 40 denominator: 7).
FFITutorial new fractionToDouble: aFraction handle.
>>> 5.714285714285714
]]]

!!!! Using external objects as ==self== argument

To make our bindings more object-oriented, the next step is to move the behaviour manipulating our objects closer to our objects.
In other words, define our call\-outs in the classes they manipulate, e.g., ask a fraction to transform itself into double.

[[[language=smalltalk
aFraction asDouble.
>>> 5.714285714285714
]]]

A naïve, yet working, implementation of such binding requires to move our already-existing methods to the FractionStructure class:

[[[language=smalltalk
FractionStructure >> asDouble [
  ^ self fractionToDouble: self
]

FractionStructure >> fractionToDouble: aFraction [
  ^ self ffiCall: #(double fraction_to_double(FractionStructure* a_fraction))
]
]]]

However, uFFI allows us to enhance our bindings even further, combining external objects with ==self== arguments in our call\-outs.
Indeed, our methods ==asDouble== and ==fractionToDouble:== can be merged in a single one using ==self== as a literal argument of the function.

[[[language=smalltalk
FractionStructure >> asDouble [
  ^ self ffiCall: #(double fraction_to_double((FractionStructure *)self))
]
]]]

!!!! Opaque Objects
UnifiedFFI can work with opaque types (An opaque datatype is an structure which fields are not visible and is always accessed through a pointer 
to it, see *https://en.wikipedia.org/wiki/Opaque_data_type*).
This is usefull when working with obscure types (types we do not know its composition).
Take this as an example (taken from SQLite bindings): 

[[[ 
typedef struct sqlite3 sqlite3;
typedef struct sqlite3_stmt sqlite3_stmt;
]]]

this defines a type of a structure, and then is used along the api in this way: 

[[[
int sqlite3_open(char *filename, sqlite3 **handle);
char *sqlite3_column_name(sqlite3_stmt* aStatement, int aColumn)
]]]

this means we always access them through a reference. Now, we could declare the pointer to the structures (using ==FFIExternalObject==), 
but then our declarations wouldn't be as close to C as we want, as we need to change the declaration.

This is where ==FFIOpaqueObject== come to help: we declare it and then we use it always as reference.

In the case of the example, it would work like this: 

[[[ 
SQLite3 class >> initialize [
	sqlite3 := #FFIOpaqueObject.
	sqlite3_stmt :=	#FFIOpaqueObject.
]

SQLite3 class >> primOpen: filename handle: handle [
	self ffiCall: #(int sqlite3_open(String filename, sqlite3 **handle)).
]

SQLite3 >> primColumnBlob: aStatement column: aColumn [
	self ffiCall: #(const void *sqlite3_column_blob (sqlite3_stmt* aStatement, int aColumn))
]
]]]

!!! Conclusion